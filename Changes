I can see the issues. The problem is with the getFilteredObservations() function and how the export is handling dates. Let me fix this and also restore the proper PDF export functionality:

```javascript
<script>
    // ... (keep all your existing code up to the getFilteredObservations function)

    // Get filtered observations for export - FIXED VERSION
    getFilteredObservations(startDate = null, endDate = null) {
        if (!startDate && !endDate) {
            return [...this.observations]; // Return copy of all observations
        }

        const start = startDate ? new Date(startDate + 'T00:00:00') : null;
        const end = endDate ? new Date(endDate + 'T23:59:59') : null;

        return this.observations.filter(obs => {
            const obsDate = new Date(obs.timestamp);
            
            if (start && obsDate < start) return false;
            if (end && obsDate > end) return false;
            return true;
        });
    },

    // Handle export generation - FIXED VERSION
    handleExport() {
        const format = document.querySelector('input[name="export-format"]:checked').value;
        const dateFrom = document.getElementById('date-from').value;
        const dateTo = document.getElementById('date-to').value;
        
        // Get filtered observations
        let filteredObservations = this.getFilteredObservations(dateFrom, dateTo);
        
        console.log('Exporting:', {
            dateFrom,
            dateTo,
            allObservations: this.observations.length,
            filteredObservations: filteredObservations.length,
            observations: filteredObservations
        });
        
        if (filteredObservations.length === 0) {
            // Check if it's because of date filtering or no data
            if (this.observations.length === 0) {
                this.showStatus('No observations recorded yet', 'error', 'export');
            } else if ((dateFrom || dateTo) && filteredObservations.length === 0) {
                this.showStatus('No observations found for the selected date range', 'error', 'export');
            } else {
                this.showStatus('No observations to export', 'error', 'export');
            }
            return;
        }
        
        if (format === 'csv') {
            this.exportToCSV(filteredObservations);
        } else {
            this.exportToPDF(filteredObservations);
        }
    },

    // Export to PDF - COMPLETE VERSION
    exportToPDF(observations) {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF();
        
        // Show progress
        const progressDiv = document.getElementById('pdf-progress');
        const progressBar = document.getElementById('pdf-progress-bar');
        const statusText = document.getElementById('pdf-status-text');
        const currentAction = document.getElementById('pdf-current-action');
        
        progressDiv.style.display = 'block';
        progressBar.value = 0;
        statusText.textContent = 'Preparing PDF...';
        
        try {
            // Set initial progress
            progressBar.value = 10;
            currentAction.textContent = 'Setting up document...';
            
            // Title Page
            pdf.setFontSize(24);
            pdf.setTextColor(40, 60, 80);
            pdf.text('EcoLens Field Observations Report', 105, 30, { align: 'center' });
            
            pdf.setFontSize(14);
            pdf.setTextColor(100, 100, 100);
            pdf.text(`Report Generated: ${new Date().toLocaleString()}`, 105, 45, { align: 'center' });
            pdf.text(`Total Observations: ${observations.length}`, 105, 55, { align: 'center' });
            
            // Add summary box
            pdf.setDrawColor(70, 130, 180);
            pdf.setFillColor(240, 248, 255);
            pdf.rect(20, 65, 170, 30, 'FD');
            
            pdf.setFontSize(12);
            pdf.setTextColor(40, 60, 80);
            pdf.text('Report Summary', 105, 75, { align: 'center' });
            
            pdf.setFontSize(10);
            pdf.setTextColor(80, 80, 80);
            
            // Calculate statistics
            const habitats = {};
            const observationTypes = {};
            let withPhotos = 0;
            let withCoordinates = 0;
            
            observations.forEach(obs => {
                habitats[obs.habitat] = (habitats[obs.habitat] || 0) + 1;
                observationTypes[obs.observationType] = (observationTypes[obs.observationType] || 0) + 1;
                if (obs.photo) withPhotos++;
                if (obs.location.coordinates) withCoordinates++;
            });
            
            const mostCommonHabitat = Object.keys(habitats).reduce((a, b) => habitats[a] > habitats[b] ? a : b, '');
            const mostCommonType = Object.keys(observationTypes).reduce((a, b) => observationTypes[a] > observationTypes[b] ? a : b, '');
            
            pdf.text(`Date Range: ${observations[observations.length-1]?.timestamp ? new Date(observations[observations.length-1].timestamp).toLocaleDateString() : 'N/A'} to ${observations[0]?.timestamp ? new Date(observations[0].timestamp).toLocaleDateString() : 'N/A'}`, 30, 85);
            pdf.text(`Most Common Habitat: ${this.capitalizeFirst(mostCommonHabitat)} (${habitats[mostCommonHabitat]})`, 30, 92);
            pdf.text(`With Photos: ${withPhotos} (${Math.round(withPhotos/observations.length*100)}%)`, 30, 99);
            pdf.text(`With Coordinates: ${withCoordinates} (${Math.round(withCoordinates/observations.length*100)}%)`, 110, 99);
            
            progressBar.value = 25;
            currentAction.textContent = 'Creating detailed reports...';
            
            // Start detailed section
            let currentPage = 1;
            let yPos = 120;
            let observationCount = 0;
            
            // Add a new page for observations if needed
            if (yPos > 250) {
                pdf.addPage();
                currentPage++;
                yPos = 20;
            }
            
            pdf.setFontSize(16);
            pdf.setTextColor(40, 60, 80);
            pdf.text('Detailed Observations', 20, yPos);
            yPos += 15;
            
            pdf.setFontSize(10);
            pdf.setTextColor(80, 80, 80);
            
            // Process each observation
            observations.forEach((obs, index) => {
                progressBar.value = 25 + ((index + 1) / observations.length * 70);
                currentAction.textContent = `Processing observation ${index + 1} of ${observations.length}...`;
                
                // Check if we need a new page
                if (yPos > 250) {
                    pdf.addPage();
                    currentPage++;
                    yPos = 20;
                    
                    // Add page header
                    pdf.setFontSize(14);
                    pdf.text(`EcoLens Field Observations (Page ${currentPage})`, 105, 15, { align: 'center' });
                    pdf.setFontSize(10);
                    yPos = 30;
                }
                
                // Observation header with background
                pdf.setFillColor(240, 248, 255);
                pdf.rect(20, yPos - 5, 170, 70, 'F');
                pdf.setDrawColor(200, 220, 240);
                pdf.rect(20, yPos - 5, 170, 70);
                
                // Observation number and ID
                pdf.setFontSize(12);
                pdf.setTextColor(40, 60, 80);
                pdf.text(`Observation ${index + 1}: ${obs.id}`, 25, yPos);
                
                // Basic info in two columns
                pdf.setFontSize(10);
                pdf.setTextColor(80, 80, 80);
                
                // Left column
                pdf.text(`Species: ${obs.scientificName}`, 25, yPos + 8);
                if (obs.commonName) {
                    pdf.text(`Common Name: ${obs.commonName}`, 25, yPos + 14);
                }
                pdf.text(`Date: ${new Date(obs.timestamp).toLocaleString()}`, 25, yPos + 20);
                pdf.text(`Observer: ${obs.observerName}`, 25, yPos + 26);
                
                // Right column
                pdf.text(`Habitat: ${this.capitalizeFirst(obs.habitat)}`, 110, yPos + 8);
                pdf.text(`Type: ${this.formatObservationType(obs.observationType)}`, 110, yPos + 14);
                pdf.text(`Location: ${obs.location.text.substring(0, 30)}${obs.location.text.length > 30 ? '...' : ''}`, 110, yPos + 20);
                
                // Characteristics (truncated if long)
                if (obs.characteristics) {
                    const chars = obs.characteristics.length > 100 ? 
                        obs.characteristics.substring(0, 100) + '...' : 
                        obs.characteristics;
                    pdf.text(`Description: ${chars}`, 25, yPos + 34);
                }
                
                // Equipment
                if (obs.equipment && obs.equipment.length > 0) {
                    pdf.text(`Equipment: ${obs.equipment.map(eq => this.formatEquipment(eq)).join(', ').substring(0, 40)}${obs.equipment.join(', ').length > 40 ? '...' : ''}`, 25, yPos + 40);
                }
                
                // Additional info
                const hasPhoto = obs.photo ? 'Yes' : 'No';
                const hasCoords = obs.location.coordinates ? 'Yes' : 'No';
                pdf.text(`Photo: ${hasPhoto} | Coordinates: ${hasCoords}`, 25, yPos + 46);
                
                yPos += 75;
                observationCount++;
                
                // Add a small separator between observations
                if (index < observations.length - 1) {
                    pdf.setDrawColor(220, 220, 220);
                    pdf.line(20, yPos - 2, 190, yPos - 2);
                    yPos += 5;
                }
            });
            
            // Add statistics page
            progressBar.value = 95;
            currentAction.textContent = 'Adding statistics...';
            
            pdf.addPage();
            
            // Statistics title
            pdf.setFontSize(20);
            pdf.setTextColor(40, 60, 80);
            pdf.text('Observations Statistics', 105, 30, { align: 'center' });
            
            // Habitat distribution chart
            pdf.setFontSize(14);
            pdf.text('Habitat Distribution', 20, 50);
            
            let habitatY = 60;
            Object.entries(habitats).sort((a, b) => b[1] - a[1]).forEach(([habitat, count]) => {
                const percentage = (count / observations.length * 100).toFixed(1);
                const barWidth = (count / Math.max(...Object.values(habitats))) * 100;
                
                pdf.setFontSize(10);
                pdf.setTextColor(80, 80, 80);
                pdf.text(`${this.capitalizeFirst(habitat)}:`, 20, habitatY);
                pdf.text(`${count} (${percentage}%)`, 180, habitatY, { align: 'right' });
                
                // Bar
                pdf.setFillColor(70, 130, 180);
                pdf.rect(60, habitatY - 3, barWidth, 5, 'F');
                
                habitatY += 10;
            });
            
            // Observation type distribution
            pdf.setFontSize(14);
            pdf.text('Observation Type Distribution', 20, 130);
            
            let typeY = 140;
            Object.entries(observationTypes).sort((a, b) => b[1] - a[1]).forEach(([type, count]) => {
                const percentage = (count / observations.length * 100).toFixed(1);
                const barWidth = (count / Math.max(...Object.values(observationTypes))) * 100;
                
                pdf.setFontSize(10);
                pdf.setTextColor(80, 80, 80);
                pdf.text(`${this.formatObservationType(type)}:`, 20, typeY);
                pdf.text(`${count} (${percentage}%)`, 180, typeY, { align: 'right' });
                
                // Bar
                pdf.setFillColor(46, 125, 50);
                pdf.rect(80, typeY - 3, barWidth, 5, 'F');
                
                typeY += 10;
            });
            
            // Timeline chart (simplified)
            if (observations.length > 1) {
                pdf.setFontSize(14);
                pdf.text('Observation Timeline', 20, 180);
                
                // Group by date
                const byDate = {};
                observations.forEach(obs => {
                    const date = new Date(obs.timestamp).toDateString();
                    byDate[date] = (byDate[date] || 0) + 1;
                });
                
                const dates = Object.keys(byDate).slice(0, 10); // Last 10 dates
                const maxCount = Math.max(...Object.values(byDate));
                
                let timelineY = 190;
                dates.forEach(date => {
                    const count = byDate[date];
                    const barWidth = (count / maxCount) * 100;
                    
                    pdf.setFontSize(8);
                    pdf.text(date.substring(0, 10), 20, timelineY);
                    pdf.text(count.toString(), 180, timelineY, { align: 'right' });
                    
                    // Bar
                    pdf.setFillColor(255, 152, 0);
                    pdf.rect(50, timelineY - 2, barWidth, 4, 'F');
                    
                    timelineY += 8;
                });
            }
            
            // Finalize
            progressBar.value = 100;
            currentAction.textContent = 'Finalizing PDF...';
            
            // Add page numbers
            const pageCount = pdf.internal.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                pdf.setPage(i);
                pdf.setFontSize(8);
                pdf.setTextColor(150, 150, 150);
                pdf.text(`Page ${i} of ${pageCount}`, 190, 287, { align: 'right' });
                pdf.text('EcoLens Field Observation Tool', 10, 287);
            }
            
            // Generate download
            const pdfBlob = pdf.output('blob');
            const pdfUrl = URL.createObjectURL(pdfBlob);
            
            // Hide progress and show download
            setTimeout(() => {
                progressDiv.style.display = 'none';
                this.showExportDownload(pdfUrl, `EcoLens_Report_${new Date().toISOString().slice(0,10)}.pdf`);
                this.showStatus(`Successfully exported ${observations.length} observations to PDF`, 'success', 'export');
            }, 500);
            
        } catch (error) {
            console.error('Error generating PDF:', error);
            progressDiv.style.display = 'none';
            this.showStatus(`Error generating PDF: ${error.message}`, 'error', 'export');
        }
    },

    // Show export download link
    showExportDownload(url, filename) {
        const downloadLink = document.getElementById('download-link');
        downloadLink.href = url;
        downloadLink.download = filename;
        document.getElementById('export-download').style.display = 'block';
        downloadLink.scrollIntoView({ behavior: 'smooth' });
    },

    // ... (keep the rest of your existing code)

    // Utility: Capitalize first letter
    capitalizeFirst(string) {
        if (!string) return '';
        return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
    }
};

// Initialize the app when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    EcoLens.init();
});

// Add offline detection
window.addEventListener('online', () => {
    console.log('App is online');
});

window.addEventListener('offline', () => {
    console.log('App is offline - data saved locally');
    EcoLens.showStatus('You are offline. Observations are saved locally.', 'info');
});

// Check if localStorage is available
try {
    localStorage.setItem('test', 'test');
    localStorage.removeItem('test');
} catch (e) {
    console.error('localStorage is not available:', e);
    EcoLens.showStatus('Warning: Local storage is disabled. Data will not be saved.', 'error');
}
</script>
```

Key fixes made:

1. Fixed getFilteredObservations(): Now properly handles date filtering and returns a copy of the array to prevent issues.
2. Fixed handleExport(): Added better logging and error messages. Now properly checks if there are observations before attempting export.
3. Complete PDF export: Restored the full PDF export functionality with:
   路 Title page with summary
   路 Detailed observation pages
   路 Statistics page with charts
   路 Progress indicator
   路 Proper formatting and styling
4. Date filtering: Fixed the date comparison logic to properly include observations within the selected date range.
5. Array copying: Added [...this.observations] to create a copy of the observations array to prevent modification issues.

Additional improvements you might want:

If you're still having issues with only new observations showing, add this debug function:

```javascript
// Add this debug function to check what's being exported
debugExport() {
    console.log('=== DEBUG EXPORT ===');
    console.log('All observations:', this.observations.length);
    console.log('Observations:', this.observations);
    
    const dateFrom = document.getElementById('date-from').value;
    const dateTo = document.getElementById('date-to').value;
    console.log('Date range:', dateFrom, 'to', dateTo);
    
    const filtered = this.getFilteredObservations(dateFrom, dateTo);
    console.log('Filtered:', filtered.length);
    console.log('Filtered observations:', filtered);
    
    // Check localStorage directly
    const stored = localStorage.getItem('ecolens_observations');
    console.log('Raw localStorage:', stored);
    
    this.showStatus(`Debug: ${this.observations.length} total, ${filtered.length} filtered`, 'info', 'export');
},
```

And add a debug button in your HTML:

```html
<button onclick="EcoLens.debugExport()" class="btn btn-outline btn-block" style="margin-top: 0.5rem;">
     Debug Export
</button>
```

This should resolve all your export issues. The export will now include all observations in the logbook (or filtered by date if specified), and the PDF will be complete with all the features it had before.
