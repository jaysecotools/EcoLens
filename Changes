// Export to PDF - FIXED VERSION with proper spacing
exportToPDF(observations) {
    if (this.isGeneratingPDF) {
        this.showStatus('PDF generation already in progress', 'warning', 'export');
        return;
    }

    this.isGeneratingPDF = true;
    const exportBtn = document.getElementById('generate-export');
    const originalText = exportBtn.textContent;
    exportBtn.innerHTML = '<span class="loading"></span> Generating PDF...';
    exportBtn.disabled = true;

    // Show progress UI
    const progressUI = document.getElementById('pdf-progress');
    const progressBar = document.getElementById('pdf-progress-bar');
    const statusText = document.getElementById('pdf-status-text');
    const currentAction = document.getElementById('pdf-current-action');
    
    progressUI.style.display = 'block';
    progressBar.value = 0;
    statusText.textContent = 'Preparing PDF document...';
    currentAction.textContent = '';

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({
        orientation: 'portrait',
        unit: 'mm',
        format: 'a4'
    });

    const margin = 15;
    const pageWidth = doc.internal.pageSize.width;
    const pageHeight = doc.internal.pageSize.height;
    const contentWidth = pageWidth - (margin * 2);
    let y = margin;
    let currentPage = 1;
    const totalObservations = observations.length;
    let processedObservations = 0;

    // Helper function to check if we need a new page
    const checkPageSpace = (requiredSpace) => {
        if (y + requiredSpace > pageHeight - margin) {
            addNewPage();
            return true;
        }
        return false;
    };

    // Helper function to add new page
    const addNewPage = () => {
        doc.addPage();
        currentPage++;
        y = margin;
        
        // Add page header
        doc.setFontSize(10);
        doc.setTextColor(100);
        doc.text(`EcoLens Field Log - Page ${currentPage}`, margin, y);
        y += 5;
        
        // Add page separator
        doc.setDrawColor(200);
        doc.line(margin, y, pageWidth - margin, y);
        y += 10;
    };

    // Helper function to add text with word wrap and return new y position
    const addWrappedText = (text, x, startY, maxWidth, lineHeight = 6) => {
        if (!text || text.trim() === '') return startY;
        
        const lines = doc.splitTextToSize(text, maxWidth);
        
        // Check if we have enough space
        if (checkPageSpace(lines.length * lineHeight)) {
            startY = y;
        }
        
        lines.forEach((line, index) => {
            // Check for each line if we need new page
            if (startY + (index * lineHeight) > pageHeight - margin) {
                addNewPage();
                startY = y;
            }
            doc.text(line, x, startY + (index * lineHeight));
        });
        
        return startY + (lines.length * lineHeight);
    };

    // Helper function to add section header with proper spacing
    const addSectionHeader = (text, sectionSpacing = true) => {
        // Add spacing before section if requested
        if (sectionSpacing) {
            y += 5;
        }
        
        // Check if we have space for header (header + 5mm margin)
        checkPageSpace(15);
        
        doc.setFontSize(12);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(40, 40, 40);
        doc.text(text, margin, y);
        y += 8;
        
        // Add underline
        doc.setDrawColor(100, 150, 100);
        doc.line(margin, y, margin + 50, y);
        y += 10;
        
        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        doc.setTextColor(60);
        
        return y;
    };

    // Helper function to add key-value pair with proper spacing
    const addKeyValue = (key, value, indent = 0, maxValueWidth = null) => {
        if (!value || value === '' || value === 'Not specified') return y;
        
        const x = margin + indent;
        const keyText = `${key}: `;
        
        // Check if we have space for at least one line
        checkPageSpace(10);
        
        doc.setFont('helvetica', 'bold');
        const keyWidth = doc.getTextWidth(keyText);
        doc.text(keyText, x, y);
        
        doc.setFont('helvetica', 'normal');
        const valueX = x + keyWidth;
        const valueWidth = maxValueWidth || (contentWidth - indent - keyWidth);
        
        y = addWrappedText(value, valueX, y, valueWidth, 5);
        y += 4;
        return y;
    };

    // Update progress
    const updateProgress = (step, action) => {
        const progress = Math.round((processedObservations / totalObservations) * 100);
        progressBar.value = progress;
        currentAction.textContent = action;
        
        if (step === 'observation') {
            processedObservations++;
            statusText.textContent = `Processing observation ${processedObservations} of ${totalObservations}`;
        }
    };

    // Generate PDF asynchronously to show progress
    setTimeout(async () => {
        try {
            // Cover page
            updateProgress('cover', 'Creating cover page...');
            
            doc.setFontSize(24);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(40, 100, 60);
            doc.text('ECOLENS FIELD LOG', pageWidth / 2, 60, { align: 'center' });
            
            doc.setFontSize(16);
            doc.setTextColor(80);
            doc.text('Field Observation Report', pageWidth / 2, 75, { align: 'center' });
            
            // Report details
            doc.setFontSize(12);
            doc.setFont('helvetica', 'normal');
            y = 100;
            
            const dateFrom = document.getElementById('date-from').value;
            const dateTo = document.getElementById('date-to').value;
            let dateRangeText = 'All observations';
            if (dateFrom || dateTo) {
                dateRangeText = `From: ${dateFrom || 'Start'} to ${dateTo || 'End'}`;
            }
            
            doc.text(`Report Period: ${dateRangeText}`, pageWidth / 2, y, { align: 'center' });
            y += 10;
            doc.text(`Total Observations: ${totalObservations}`, pageWidth / 2, y, { align: 'center' });
            y += 10;
            doc.text(`Generated: ${new Date().toLocaleString()}`, pageWidth / 2, y, { align: 'center' });
            y += 20;
            
            doc.setFontSize(10);
            doc.setTextColor(100);
            doc.text('This report contains detailed field observations including photos,', pageWidth / 2, y, { align: 'center' });
            y += 5;
            doc.text('location data, and comprehensive metadata for each record.', pageWidth / 2, y, { align: 'center' });
            
            // Table of contents
            addNewPage();
            updateProgress('toc', 'Creating table of contents...');
            addSectionHeader('Table of Contents', false);
            
            y += 10;
            observations.forEach((obs, index) => {
                // Check space for each TOC entry
                checkPageSpace(7);
                const entry = `${index + 1}. ${obs.scientificName} (${obs.id})`;
                doc.text(entry, margin, y);
                y += 7;
            });
            
            // Process each observation
            for (let i = 0; i < observations.length; i++) {
                const obs = observations[i];
                
                // Add new page for each observation (except first after TOC)
                if (i > 0 || currentPage > 2) {
                    addNewPage();
                }
                
                updateProgress('observation', `Adding observation: ${obs.scientificName}`);
                
                // Observation header
                checkPageSpace(20); // Space for header
                doc.setFontSize(14);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(40, 40, 40);
                doc.text(`Observation ${i + 1}: ${obs.id}`, margin, y);
                y += 10;
                
                // Observation details in two columns
                const col1X = margin;
                const col2X = margin + (contentWidth / 2) + 5;
                const columnWidth = (contentWidth / 2) - 5;
                
                // Start columns at same y position
                let col1Y = y;
                let col2Y = y;
                
                // COLUMN 1: Basic Information
                doc.setFontSize(10);
                doc.setFont('helvetica', 'bold');
                doc.text('BASIC INFORMATION', col1X, col1Y);
                col1Y += 7; // Space after heading
                doc.setFont('helvetica', 'normal');
                
                // Add key-value pairs in column 1
                const col1Items = [
                    { key: 'Date/Time', value: new Date(obs.timestamp).toLocaleString() },
                    { key: 'Scientific Name', value: obs.scientificName },
                    { key: 'Common Name', value: obs.commonName || 'Not specified' },
                    { key: 'Habitat', value: this.capitalizeFirst(obs.habitat) },
                    { key: 'Observation Type', value: this.formatObservationType(obs.observationType) }
                ];
                
                col1Items.forEach(item => {
                    doc.setFont('helvetica', 'bold');
                    const keyText = `${item.key}: `;
                    const keyWidth = doc.getTextWidth(keyText);
                    doc.text(keyText, col1X, col1Y);
                    
                    doc.setFont('helvetica', 'normal');
                    const wrappedLines = doc.splitTextToSize(item.value, columnWidth - keyWidth);
                    
                    // Handle multi-line values
                    if (wrappedLines.length === 1) {
                        doc.text(item.value, col1X + keyWidth, col1Y);
                        col1Y += 5;
                    } else {
                        // First line
                        doc.text(wrappedLines[0], col1X + keyWidth, col1Y);
                        col1Y += 5;
                        
                        // Subsequent lines (indented)
                        for (let j = 1; j < wrappedLines.length; j++) {
                            doc.text(wrappedLines[j], col1X + keyWidth, col1Y);
                            col1Y += 5;
                        }
                    }
                    col1Y += 1; // Extra space between items
                });
                
                // COLUMN 2: Location & Equipment
                doc.setFont('helvetica', 'bold');
                doc.text('LOCATION & EQUIPMENT', col2X, col2Y);
                col2Y += 7; // Space after heading
                doc.setFont('helvetica', 'normal');
                
                // Add key-value pairs in column 2
                const col2Items = [];
                
                // Location text
                col2Items.push({ key: 'Location', value: obs.location.text });
                
                // Coordinates if available
                if (obs.location.coordinates) {
                    const coords = `Lat: ${obs.location.coordinates.lat.toFixed(5)}, Lng: ${obs.location.coordinates.lng.toFixed(5)}`;
                    col2Items.push({ key: 'Coordinates', value: coords });
                }
                
                // Accuracy if available
                if (obs.location.accuracy) {
                    col2Items.push({ key: 'Accuracy', value: `Â±${Math.round(obs.location.accuracy)} meters` });
                }
                
                // Equipment if available
                if (obs.equipment && obs.equipment.length > 0) {
                    const equipmentText = obs.equipment.map(eq => this.formatEquipment(eq)).join(', ');
                    col2Items.push({ key: 'Equipment Used', value: equipmentText });
                }
                
                // References if available
                if (obs.references) {
                    col2Items.push({ key: 'References', value: obs.references });
                }
                
                col2Items.forEach(item => {
                    doc.setFont('helvetica', 'bold');
                    const keyText = `${item.key}: `;
                    const keyWidth = doc.getTextWidth(keyText);
                    doc.text(keyText, col2X, col2Y);
                    
                    doc.setFont('helvetica', 'normal');
                    const wrappedLines = doc.splitTextToSize(item.value, columnWidth - keyWidth);
                    
                    // Handle multi-line values
                    if (wrappedLines.length === 1) {
                        doc.text(item.value, col2X + keyWidth, col2Y);
                        col2Y += 5;
                    } else {
                        // First line
                        doc.text(wrappedLines[0], col2X + keyWidth, col2Y);
                        col2Y += 5;
                        
                        // Subsequent lines (indented)
                        for (let j = 1; j < wrappedLines.length; j++) {
                            doc.text(wrappedLines[j], col2X + keyWidth, col2Y);
                            col2Y += 5;
                        }
                    }
                    col2Y += 1; // Extra space between items
                });
                
                // Set y to the bottom of the tallest column
                y = Math.max(col1Y, col2Y) + 10;
                
                // Characteristics section
                if (obs.characteristics) {
                    y = addSectionHeader('DESCRIPTION / CHARACTERISTICS');
                    y = addWrappedText(obs.characteristics, margin, y, contentWidth, 5);
                    y += 10;
                }
                
                // Notes section
                if (obs.notes) {
                    y = addSectionHeader('ADDITIONAL NOTES');
                    y = addWrappedText(obs.notes, margin, y, contentWidth, 5);
                    y += 10;
                }
                
                // Photo section
                if (obs.photo && obs.photo.data) {
                    y = addSectionHeader('PHOTO / EVIDENCE');
                    
                    try {
                        updateProgress('photo', `Adding photo for: ${obs.scientificName}`);
                        
                        // Check if we have enough space for the photo (80mm minimum)
                        checkPageSpace(80);
                        
                        // Add photo caption
                        doc.setFontSize(9);
                        doc.setTextColor(80);
                        doc.text('Observation Photo:', margin, y);
                        y += 5;
                        
                        // Add photo with fixed aspect ratio
                        const maxImgWidth = contentWidth;
                        const maxImgHeight = 80; // Max height for photos
                        
                        // Convert base64 to image object
                        const img = new Image();
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = reject;
                            img.src = obs.photo.data;
                        });
                        
                        // Calculate dimensions maintaining aspect ratio
                        let imgWidth = img.width;
                        let imgHeight = img.height;
                        const aspectRatio = imgWidth / imgHeight;
                        
                        if (imgWidth > maxImgWidth) {
                            imgWidth = maxImgWidth;
                            imgHeight = imgWidth / aspectRatio;
                        }
                        
                        if (imgHeight > maxImgHeight) {
                            imgHeight = maxImgHeight;
                            imgWidth = imgHeight * aspectRatio;
                        }
                        
                        // Center the image
                        const imgX = margin + (contentWidth - imgWidth) / 2;
                        
                        // Add image to PDF
                        doc.addImage(
                            img,
                            'JPEG',
                            imgX,
                            y,
                            imgWidth,
                            imgHeight
                        );
                        
                        y += imgHeight + 10;
                        
                        // Add photo metadata
                        doc.setFontSize(8);
                        doc.setTextColor(100);
                        const imgMetadata = `File: ${obs.photo.filename || 'photo.jpg'} | Included in record`;
                        doc.text(imgMetadata, margin, y);
                        y += 6;
                        
                    } catch (error) {
                        console.error('Error adding photo to PDF:', error);
                        doc.setFontSize(9);
                        doc.setTextColor(150, 0, 0);
                        doc.text('Photo could not be included in PDF (format issue)', margin, y);
                        y += 10;
                    }
                }
                
                // Metadata footer
                doc.setFontSize(8);
                doc.setTextColor(120);
                doc.setFont('helvetica', 'italic');
                
                // Check space for metadata
                checkPageSpace(20);
                
                const metadataLines = [
                    `Record ID: ${obs.id}`,
                    `Created: ${new Date(obs.timestamp).toLocaleString()}`,
                    `Last Modified: ${new Date(obs.metadata.lastModified).toLocaleString()}`,
                    `Device: ${obs.metadata.deviceInfo.substring(0, 40)}...`
                ];
                
                metadataLines.forEach(line => {
                    doc.text(line, margin, y);
                    y += 4;
                });
                
                y += 10;
                
                // Add page separator if not last observation
                if (i < observations.length - 1) {
                    checkPageSpace(15);
                    doc.setDrawColor(200);
                    doc.setLineWidth(0.5);
                    doc.line(margin, y, pageWidth - margin, y);
                    y += 15;
                }
            }
            
            // Final page - summary
            addNewPage();
            updateProgress('summary', 'Adding summary page...');
            
            addSectionHeader('REPORT SUMMARY', false);
            y += 10;
            
            doc.setFontSize(11);
            doc.setFont('helvetica', 'bold');
            doc.text('Statistics:', margin, y);
            y += 10;
            
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(10);
            
            // Count by habitat
            const habitatCount = {};
            observations.forEach(obs => {
                habitatCount[obs.habitat] = (habitatCount[obs.habitat] || 0) + 1;
            });
            
            doc.text('Observations by Habitat Type:', margin, y);
            y += 7;
            
            Object.entries(habitatCount).forEach(([habitat, count]) => {
                checkPageSpace(5);
                doc.text(`  ${this.capitalizeFirst(habitat)}: ${count}`, margin + 5, y);
                y += 5;
            });
            
            y += 5;
            
            // Count by observation type
            const typeCount = {};
            observations.forEach(obs => {
                typeCount[obs.observationType] = (typeCount[obs.observationType] || 0) + 1;
            });
            
            doc.text('Observations by Type:', margin, y);
            y += 7;
            
            Object.entries(typeCount).forEach(([type, count]) => {
                checkPageSpace(5);
                doc.text(`  ${this.formatObservationType(type)}: ${count}`, margin + 5, y);
                y += 5;
            });
            
            y += 10;
            
            // Photos summary
            const photoCount = observations.filter(obs => obs.photo).length;
            doc.text(`Total photos included: ${photoCount}`, margin, y);
            y += 7;
            
            // Date range
            const dates = observations.map(obs => new Date(obs.timestamp)).sort((a, b) => a - b);
            if (dates.length > 0) {
                const firstDate = dates[0].toLocaleDateString();
                const lastDate = dates[dates.length - 1].toLocaleDateString();
                doc.text(`Date range: ${firstDate} to ${lastDate}`, margin, y);
                y += 7;
            }
            
            // Final message
            y += 10;
            doc.setFont('helvetica', 'italic');
            doc.setTextColor(100);
            doc.text('--- End of Report ---', pageWidth / 2, y, { align: 'center' });
            
            // Save PDF
            updateProgress('save', 'Finalizing PDF...');
            
            const filename = `EcoLens_Field_Log_${new Date().toISOString().slice(0,10)}.pdf`;
            const pdfBlob = doc.output('blob');
            const pdfUrl = URL.createObjectURL(pdfBlob);
            
            // Complete progress
            progressBar.value = 100;
            statusText.textContent = 'PDF generation complete!';
            currentAction.textContent = '';
            
            setTimeout(() => {
                this.showExportDownload(pdfUrl, filename);
                this.showStatus(`Successfully exported ${observations.length} observations to PDF`, 'success', 'export');
                
                // Reset UI
                exportBtn.textContent = originalText;
                exportBtn.disabled = false;
                this.isGeneratingPDF = false;
                
                // Hide progress after 3 seconds
                setTimeout(() => {
                    progressUI.style.display = 'none';
                }, 3000);
            }, 500);
            
        } catch (error) {
            console.error('Error generating PDF:', error);
            this.showStatus(`Error generating PDF: ${error.message}`, 'error', 'export');
            
            // Reset UI
            exportBtn.textContent = originalText;
            exportBtn.disabled = false;
            this.isGeneratingPDF = false;
            progressUI.style.display = 'none';
        }
    }, 100);
}
